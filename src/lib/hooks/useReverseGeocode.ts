import { useCallback, useState } from 'react';
import { AddressData } from '../types/types';

// üîë IMPORTANTE: Substitua pela sua API Key do LocationIQ
// Para seguran√ßa, use vari√°veis de ambiente: process.env.LOCATIONIQ_API_KEY
const LOCATIONIQ_API_KEY = 'pk.0a31f590fd3984df9fe561d3f0075324';

/**
 * Fun√ß√£o para formatar endere√ßo brasileiro
 * Formato: "Rua/Avenida Bairro, Cidade - Estado, CEP XXXXX-XXX"
 */
function formatBrazilianAddress(data: any): AddressData {
  try {
    const components = data.address || {};

    // Cidade (prioridade: city > town > suburb)
    const city =
      components.city ||
      components.town ||
      components.suburb ||
      components.village ||
      '';

    // Estado (prioridade: state > state_district)
    const state = components.state || components.state_district || '';

    // Bairro (prioridade: neighbourhood > suburb)
    const neighbourhood = components.neighbourhood || components.suburb || '';

    // Rua (prioridade: road > street > pedestrian)
    const road =
      components.road || components.street || components.pedestrian || '';

    // N√∫mero da casa
    const houseNumber = components.house_number || components.road_number || '';

    // CEP
    const cep = components.postcode || '';

    // Construir endere√ßo formatado
    let formattedParts: string[] = [];

    // Rua + N√∫mero
    if (road) {
      const streetPart = houseNumber ? `${road}, ${houseNumber}` : road;
      formattedParts.push(streetPart);
    }

    // Bairro
    if (neighbourhood && neighbourhood !== city) {
      formattedParts.push(neighbourhood);
    }

    // Cidade - Estado
    if (city) {
      const locationPart = state ? `${city} - ${state}` : city;
      formattedParts.push(locationPart);
    }

    // CEP
    if (cep) {
      const formattedCep = formatCEP(cep);
      formattedParts.push(formattedCep);
    }

    // Montar endere√ßo final
    const formattedAddress =
      formattedParts.length > 0
        ? formattedParts.join(', ')
        : components.display_name || 'Endere√ßo n√£o identificado';

    // Retornar todos os dados com formata√ß√£o customizada
    return {
      // Formata√ß√£o customizada
      display_name: components.display_name || formattedAddress,
      formatted: formattedAddress,

      // Dados brutos do LocationIQ
      place_id: data.place_id,
      licence: data.licence,
      osm_type: data.osm_type,
      osm_id: data.osm_id,
      boundingbox: data.boundingbox,
      lat: data.lat,
      lon: data.lon,
      class: data.class,
      type: data.type,
      formatted_address: components.display_name,

      // Componentes brasileiros
      road,
      neighbourhood,
      city,
      state,
      postcode: cep,
      house_number: houseNumber,

      // Backup com todos os componentes
      ...components,
    };
  } catch (error) {
    console.error('Erro ao formatar endere√ßo brasileiro:', error);
    // Fallback para display_name original
    return {
      display_name: data.display_name || 'Endere√ßo n√£o identificado',
      formatted: data.display_name || 'Endere√ßo n√£o identificado',
      ...data,
    };
  }
}

/**
 * Formata CEP para padr√£o brasileiro XXXXX-XXX
 */
function formatCEP(cep: string): string {
  if (!cep) return '';

  // Remove caracteres n√£o num√©ricos
  const cleanCep = cep.replace(/\D/g, '');

  // Se j√° est√° no formato correto, retorna
  if (cleanCep.length === 8 && !cep.includes('-')) {
    return `${cleanCep.substring(0, 5)}-${cleanCep.substring(5)}`;
  }

  // Se j√° tem h√≠fen, retorna como est√°
  if (cep.includes('-')) {
    return cep;
  }

  return cep;
}

/**
 * Hook para fazer reverse geocoding via LocationIQ com formata√ß√£o brasileira.
 * - Retorna fun√ß√£o `lookup` para buscar endere√ßo por lat/lon.
 * - Formata automaticamente para padr√£o brasileiro.
 * - Respeita rate limits do LocationIQ (5.000 req/dia no plano free).
 */
export function useReverseGeocode() {
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const lookup = useCallback(
    async (latitude: number, longitude: number): Promise<AddressData> => {
      setError(null);
      setLoading(true);

      try {
        const url = `https://us1.locationiq.com/v1/reverse?key=${LOCATIONIQ_API_KEY}&lat=${latitude}&lon=${longitude}&format=json&addressdetails=1`;

        console.log('üîç Buscando endere√ßo para:', {
          latitude: latitude.toFixed(6),
          longitude: longitude.toFixed(6),
        });

        const res = await fetch(url);
        if (!res.ok) {
          const text = await res.text();
          throw new Error(`LocationIQ respondeu com ${res.status}: ${text}`);
        }

        const json = await res.json();

        if (!json || json.error) {
          throw new Error(json.error?.message || 'Resposta inv√°lida da API');
        }

        // ‚úÖ Formata√ß√£o brasileira customizada
        const addressData = formatBrazilianAddress(json);

        console.log('üìç Endere√ßo formatado:', {
          original: json.display_name,
          brasileiro: addressData.formatted,
          componentes: {
            rua: addressData.road,
            bairro: addressData.neighbourhood,
            cidade: addressData.city,
            estado: addressData.state,
            cep: addressData.postcode,
          },
        });

        setLoading(false);
        return addressData;
      } catch (err: any) {
        const errorMessage =
          err?.message ?? 'Erro desconhecido no reverse geocoding';
        console.error('‚ùå Erro no geocoding:', errorMessage);
        setError(errorMessage);
        setLoading(false);
        throw new Error(errorMessage);
      }
    },
    [],
  );

  return { lookup, loading, error };
}
