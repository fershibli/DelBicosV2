name: 01 - Análise Semântica Pós-Merge

# Gatilho: Acionado QUANDO um Pull Request é FECHADO.
on:
  pull_request:
    types: [ closed ]
    branches:
      - main # Apenas PRs direcionados à 'main'

# Permissões necessárias para ler os commits do PR.
permissions:
  pull-requests: read
  contents: read

jobs:
  analise-semantica:
    # Condições: O job só roda se:
    # 1. O PR foi de fato mergeado (e não apenas fechado).
    # 2. A branch de origem (head) era 'stag'.
    if: |
      github.event.pull_request.merged == true &&
      github.event.pull_request.head.ref == 'stag'
      
    runs-on: ubuntu-latest
    
    # Define saídas (outputs) para este job, que podem ser usadas por outros jobs
    outputs:
      bump_type: ${{ steps.analisar_versao.outputs.BUMP_TYPE }}
      bump_reason: ${{ steps.analisar_versao.outputs.BUMP_REASON }}

    steps:
      - name: 1. Listar Commits do PR (via API)
        id: get_commits
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string # Garante que a saída seja uma string
          script: |
            console.log(`Analisando commits do PR #${context.issue.number}`);
            
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            // Mapeia para uma lista de mensagens de commit
            const messages = commits.map(c => c.commit.message.split('\n')[0]); // Pega apenas a primeira linha
            
            // Retorna a lista de mensagens, separadas por nova linha
            const commitMessages = messages.join('\n');
            console.log("Commits analisados:\n" + commitMessages);
            return commitMessages;

      - name: 2. Analisar Commits e Determinar Versão
        id: analisar_versao
        run: |
          # Pega a string de commits do passo anterior
          COMMITS=$(echo "${{ steps.get_commits.outputs.result }}")
          
          BUMP_TYPE="Nenhum"
          BUMP_REASON=""

          # Lógica de versionamento com as NOVAS regras (incluindo "refatorar" e "refatoração")
          # A ordem de prioridade (MAJOR > MINOR > PATCH) é mantida.
          
          if echo "$COMMITS" | grep -q -i -E "^(refactor|refatorar|refatoração):"; then
            BUMP_TYPE="MAJOR"
            BUMP_REASON="Um commit 'refactor/refatorar/refatoração:' foi encontrado, indicando uma atualização MAJOR."
          elif echo "$COMMITS" | grep -q -i -E "^(feat|feature):"; then
            BUMP_TYPE="MINOR"
            BUMP_REASON="Um commit 'feat:' ou 'feature:' foi encontrado, indicando uma atualização MINOR."
          elif echo "$COMMITS" | grep -q -i "^fix:"; then
            BUMP_TYPE="PATCH"
            BUMP_REASON="Um commit 'fix:' foi encontrado, indicando uma atualização PATCH."
          else
            BUMP_TYPE="Nenhum"
            BUMP_REASON="Nenhum commit semântico (fix, feature, refactor, refatorar, refatoração) foi detectado."
          fi
          
          # Exibe o resultado no log
          echo "Tipo de Bump: $BUMP_TYPE"
          echo "Razão: $BUMP_REASON"
          
          # Salva como 'output' do passo
          echo "BUMP_TYPE=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "BUMP_REASON=$BUMP_REASON" >> $GITHUB_OUTPUT

      - name: 3. Exibir Resultado da Análise
        run: |
          echo "Merge de 'stag' para 'main' concluído."
          echo "Bump de versão determinado: ${{ steps.analisar_versao.outputs.BUMP_TYPE }}"
          echo "Justificativa: ${{ steps.analisar_versao.outputs.BUMP_REASON }}"

      - name: 4. Falhar se nenhum commit semântico for encontrado
        if: steps.analisar_versao.outputs.BUMP_TYPE == 'Nenhum'
        run: |
          echo "Erro: O merge foi concluído, mas nenhum commit semântico (fix, feature, refactor/refatorar/refatoração) foi encontrado."
          echo "O pipeline de release não pode determinar a próxima versão."
          exit 1