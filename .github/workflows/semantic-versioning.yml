name: 01 - An√°lise Sem√¢ntica P√≥s-Merge

# Gatilho: Acionado QUANDO um Pull Request √© FECHADO.
on:
  pull_request:
    types: [closed]
    branches:
      - main # Apenas PRs direcionados √† 'main'

# Permiss√µes necess√°rias para ler os commits do PR.
permissions:
  pull-requests: write # Mudado de 'read' para 'write'
  contents: write

jobs:
  analise-semantica:
    # Condi√ß√µes: O job s√≥ roda se:
    # 1. O PR foi de fato mergeado (e n√£o apenas fechado).
    # 2. A branch de origem (head) era 'stag'.
    if: |
      github.event.pull_request.merged == true &&
      github.event.pull_request.head.ref == 'stag'

    runs-on: ubuntu-latest

    steps:
      - name: Checar reposit√≥rio
        uses: actions/checkout@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configurar Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '22.15.1'

      - name: Instalar depend√™ncias
        run: npm install

      - name: Instalar semver (semantic versioning tool)
        run: npm install -g semver

      - name: Criar nova tag caso n√£o exista
        id: create_initial_tag
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -z "$(git tag)" ]; then
            git config --global user.name 'github-actions'
            git config --global user.email 'github-actions@github.com'
            git tag -a v0.0.0 -m "Initial release"
            git push origin v0.0.0
          fi

      - name: Calcular nova vers√£o
        id: version
        run: |
          git fetch --tags
          LAST_TAG=$(git describe --tags `git rev-list --tags --max-count=1` 2>/dev/null || echo "v0.0.0")
          echo "Vers√£o Atual: $LAST_TAG"

          # Obter commits desde a √∫ltima tag
          if [ "$LAST_TAG" = "v0.0.0" ]; then
            COMMIT_MESSAGES=$(git log --pretty=format:"%s" | tr '\n' '|')
          else
            COMMIT_MESSAGES=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s" | tr '\n' '|')
          fi

          echo "Commits desde a √∫ltima tag: $COMMIT_MESSAGES"

          # Verificar se h√° commits para processar
          if [ -z "$COMMIT_MESSAGES" ]; then
            echo "Nenhum commit encontrado desde a √∫ltima tag"
            echo "should_version=false" >> $GITHUB_ENV
            exit 0
          fi

          # Inicializando vari√°veis
          MAJOR=0
          MINOR=0
          PATCH=0

          # Analisando mensagens de commit
          IFS='|' read -ra COMMITS <<< "$COMMIT_MESSAGES"
          for COMMIT in "${COMMITS[@]}"; do
            if echo "$COMMIT" | grep -q -i -E "(^(refactor|refatorar|refatora√ß√£o)|BREAKING CHANGE)"; then
              MAJOR=1
              echo "Encontrado refactor ou BREAKING CHANGE"
            elif echo "$COMMIT" | grep -q -i -E "^(feat|feature)"; then
              MINOR=1
              echo "Encontrado feat"
            elif echo "$COMMIT" | grep -q -i "^fix"; then
              PATCH=1
              echo "Encontrado fix"
            fi
          done

          # Verificar se alguma mudan√ßa foi detectada
          if [[ $MAJOR -eq 0 && $MINOR -eq 0 && $PATCH -eq 0 ]]; then
            echo "Nenhuma mudan√ßa version√°vel detectada"
            echo "should_version=false" >> $GITHUB_ENV
            exit 0
          fi

          # Calculando a nova vers√£o usando semver
          CURRENT_VERSION=${LAST_TAG#v}
          if [[ $MAJOR -eq 1 ]]; then
            NEW_VERSION=$(semver -i major $CURRENT_VERSION)
            echo "Incrementando vers√£o MAJOR"
          elif [[ $MINOR -eq 1 ]]; then
            NEW_VERSION=$(semver -i minor $CURRENT_VERSION)
            echo "Incrementando vers√£o MINOR"
          elif [[ $PATCH -eq 1 ]]; then
            NEW_VERSION=$(semver -i patch $CURRENT_VERSION)
            echo "Incrementando vers√£o PATCH"
          fi

          echo "Nova vers√£o: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> $GITHUB_ENV
          echo "should_version=true" >> $GITHUB_ENV

      - name: Verificar se deve atualizar vers√£o
        run: |
          if [ "${{ env.should_version }}" = "false" ]; then
            echo "Pulando atualiza√ß√£o de vers√£o - nenhuma mudan√ßa detectada"
            exit 0
          fi

      - name: Atualizar vers√£o no package.json
        if: env.should_version == 'true'
        run: |
          echo "Atualizando vers√£o para ${{ env.new_version }}"
          npm version ${{ env.new_version }} --no-git-tag-version --allow-same-version

      - name: Commit e push
        if: env.should_version == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Criar branch de release
          BRANCH_NAME="release/v${{ env.new_version }}"
          git config --global user.name 'github-actions'
          git config --global user.email 'github-actions@github.com'
          git checkout -b $BRANCH_NAME
          git add package.json
          git commit -m "chore(release): version ${{ env.new_version }}" --no-verify
          git tag v${{ env.new_version }}
          git push origin $BRANCH_NAME --tags

      - name: Criar Pull Request
        if: env.should_version == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Criando PR da branch release/v${{ env.new_version }} para main..."

          # Verificar se a branch existe
          git ls-remote --heads origin release/v${{ env.new_version }} || {
            echo "Erro: Branch release/v${{ env.new_version }} n√£o encontrada!"
            exit 1
          }

          # Criar PR e capturar sa√≠da
          PR_URL=$(gh pr create \
            --base main \
            --head "release/v${{ env.new_version }}" \
            --title "chore(release): version ${{ env.new_version }}" \
            --body "üöÄ Atualiza√ß√£o autom√°tica de vers√£o para **v${{ env.new_version }}**

          **Tag criada:** \`v${{ env.new_version }}\`

          Auto-gerado pelo workflow de versionamento sem√¢ntico." 2>&1)

          echo "Resultado: $PR_URL"

          # Verificar se houve erro
          if [[ "$PR_URL" == *"error"* ]] || [[ "$PR_URL" == *"Error"* ]]; then
            echo "Erro ao criar PR: $PR_URL"
            exit 1
          fi

          # Extrair n√∫mero da PR da URL
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')

          if [ -z "$PR_NUMBER" ]; then
            echo "N√£o foi poss√≠vel extrair o n√∫mero da PR de: $PR_URL"
            exit 1
          fi

          echo "PR #$PR_NUMBER criada com sucesso!"
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_ENV

          # Tentar adicionar labels se existirem
          gh pr edit $PR_NUMBER --add-label "release" 2>/dev/null || echo "Label release n√£o encontrada, ignorando..."
          gh pr edit $PR_NUMBER --add-label "automated" 2>/dev/null || echo "Label automated n√£o encontrada, ignorando..."

      - name: Auto-aprovar e mergear PR
        if: env.should_version == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Aguardar processamento
          sleep 3

          # Aprovar a PR (se necess√°rio aprova√ß√£o)
          gh pr review ${{ env.PR_NUMBER }} --approve

          # Mergear a PR
          gh pr merge ${{ env.PR_NUMBER }} --squash --delete-branch --auto

      - name: Faz release no GitHub
        if: env.should_version == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.new_version }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Atualiza a stag a partir da main
        if: env.should_version == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name 'github-actions'
          git config --global user.email 'github-actions@github.com'
          git checkout stag
          git pull origin main
          git push origin stag
      - name: Finalizado
        run: echo "Processo de versionamento conclu√≠do."
