name: 01 - An치lise Sem칙ntica P칩s-Merge

# Gatilho: Acionado QUANDO um Pull Request 칠 FECHADO.
on:
  pull_request:
    types: [closed]
    branches:
      - main # Apenas PRs direcionados  'main'

# Permiss칫es necess치rias para ler os commits do PR.
permissions:
  pull-requests: write # Mudado de 'read' para 'write'
  contents: write

jobs:
  analise-semantica:
    # Condi칞칫es: O job s칩 roda se:
    # 1. O PR foi de fato mergeado (e n칚o apenas fechado).
    # 2. A branch de origem (head) era 'stag'.
    if: |
      github.event.pull_request.merged == true &&
      github.event.pull_request.head.ref == 'stag'

    runs-on: ubuntu-latest

    steps:
      - name: Checar reposit칩rio
        uses: actions/checkout@v2
        with:
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0

      - name: Configurar Node.js
        uses: actions/setup-node@v2
        with:
          node-version: "22.15.1"

      - name: Instalar depend칡ncias
        run: npm install

      - name: Instalar semver (semantic versioning tool)
        run: npm install -g semver

      - name: Criar nova tag caso n칚o exista
        id: create_initial_tag
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          if [ -z "$(git tag)" ]; then
            git config --global user.name 'github-actions'
            git config --global user.email 'github-actions@github.com'
            git tag -a v0.0.0 -m "Initial release"
            git push origin v0.0.0
          fi

      - name: Calcular nova vers칚o
        id: version
        run: |
          git fetch --tags
          LAST_TAG=$(git describe --tags `git rev-list --tags --max-count=1` 2>/dev/null || echo "v0.0.0")
          echo "Vers칚o Atual: $LAST_TAG"

          # Obter commits desde a 칰ltima tag
          if [ "$LAST_TAG" = "v0.0.0" ]; then
            COMMIT_MESSAGES=$(git log --pretty=format:"%s" | tr '\n' '|')
          else
            COMMIT_MESSAGES=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s" | tr '\n' '|')
          fi

          echo "Commits desde a 칰ltima tag: $COMMIT_MESSAGES"

          # Verificar se h치 commits para processar
          if [ -z "$COMMIT_MESSAGES" ]; then
            echo "Nenhum commit encontrado desde a 칰ltima tag"
            echo "should_version=false" >> $GITHUB_ENV
            exit 0
          fi

          # Inicializando vari치veis
          MAJOR=0
          MINOR=0
          PATCH=0

          # Analisando mensagens de commit
          IFS='|' read -ra COMMITS <<< "$COMMIT_MESSAGES"
          for COMMIT in "${COMMITS[@]}"; do
            if echo "$COMMIT" | grep -q -i -E "BREAKING CHANGE"; then
              MAJOR=1
              echo "Encontrado BREAKING CHANGE"
            elif echo "$COMMIT" | grep -q -i -E "^(feat|feature)"; then
              MINOR=1
              echo "Encontrado feat"
            elif echo "$COMMIT" | grep -q -i "^fix"; then
              PATCH=1
              echo "Encontrado fix"
            fi
          done

          # Verificar se alguma mudan칞a foi detectada
          if [[ $MAJOR -eq 0 && $MINOR -eq 0 && $PATCH -eq 0 ]]; then
            echo "Nenhuma mudan칞a version치vel detectada"
            echo "should_version=false" >> $GITHUB_ENV
            exit 0
          fi

          # Calculando a nova vers칚o usando semver
          CURRENT_VERSION=${LAST_TAG#v}
          if [[ $MAJOR -eq 1 ]]; then
            NEW_VERSION=$(semver -i major $CURRENT_VERSION)
            echo "Incrementando vers칚o MAJOR"
          elif [[ $MINOR -eq 1 ]]; then
            NEW_VERSION=$(semver -i minor $CURRENT_VERSION)
            echo "Incrementando vers칚o MINOR"
          elif [[ $PATCH -eq 1 ]]; then
            NEW_VERSION=$(semver -i patch $CURRENT_VERSION)
            echo "Incrementando vers칚o PATCH"
          fi

          echo "Nova vers칚o: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> $GITHUB_ENV
          echo "should_version=true" >> $GITHUB_ENV

      - name: Atualizar vers칚o no package.json (se necess치rio)
        if: env.should_version == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "Verificando/Atualizando vers칚o para ${{ env.new_version }}..."
          # Tenta atualizar. Se j치 estiver na vers칚o certa, n칚o faz nada.
          npm version ${{ env.new_version }} --no-git-tag-version --allow-same-version

          # Verificar se houve mudan칞a. Se sim, commitar direto na main.
          # (O checkout j치 est치 na 'main', pois o evento foi um merge na 'main')
          if ! git diff --quiet --exit-code package.json; then
            echo "package.json foi atualizado. Commitando na main..."
            git config --global user.name 'github-actions'
            git config --global user.email 'github-actions@github.com'
            git add package.json
            git commit -m "chore(release): version ${{ env.new_version }}" --no-verify
            git push origin main
          else
            echo "package.json j치 est치 na vers칚o correta. Pulando commit."
          fi

      - name: Verificar se a tag j치 existe
        if: env.should_version == 'true'
        run: |
          # Se a tag (ex: v1.0.0) j치 existir no reposit칩rio remoto, paramos tudo.
          if git ls-remote --exit-code --tags origin "v${{ env.new_version }}"; then
            echo "Tag v${{ env.new_version }} j치 existe remotamente."
            echo "should_version=false" >> $GITHUB_ENV
          else
            echo "Tag v${{ env.new_version }} n칚o encontrada. Pode continuar."
          fi

      - name: Faz release no GitHub (Cria a Tag e o Release)
        # Este passo agora cria a tag E o release.
        if: env.should_version == 'true'
        uses: softprops/action-gh-release@v2 # Use a v2
        with:
          tag_name: v${{ env.new_version }}
          name: Release v${{ env.new_version }}
          body: |
            游 Atualiza칞칚o autom치tica de vers칚o para **v${{ env.new_version }}**
            Auto-gerado pelo workflow de versionamento sem칙ntico.
          generate_release_notes: true # Gera notas automaticamente
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Atualiza a stag a partir da main
        if: env.should_version == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          git config --global user.name 'github-actions'
          git config --global user.email 'github-actions@github.com'
          git checkout stag
          git pull origin main
          git push origin stag

      - name: Finalizado
        run: echo "Processo de versionamento conclu칤do."
